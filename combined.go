package main


import (
    "bytes"
    "crypto/sha1"
    "fmt"
    "log"
    "net/http"
    "io"
    "io/ioutil"
    "strconv"
    "strings"
    "time"

    "github.com/PuerkitoBio/goquery"
    "golang.org/x/net/html/charset"
    "github.com/mvdan/xurls"

    "github.com/aws/aws-sdk-go/aws"
    "github.com/aws/aws-sdk-go/aws/session"
    "github.com/aws/aws-sdk-go/service/polly"
    "github.com/aws/aws-sdk-go/service/s3"
)
// TODO fill these in!
const (
    S3Region = "eu-central-1"
    S3Bucket = "pl.rrj.icm-polly"
    LinkExpiration = 180
)


func main() {

    body, err := fetchUtf8Bytes("http://www.meteo.pl/komentarze/index1.php")
    if err != nil {
        log.Println("Error: ", err)
    }

    r := bytes.NewReader(body)

    // Create a goquery document from the HTTP response
    document, err := goquery.NewDocumentFromReader(r)
    if err != nil {
        log.Println("Error loading HTTP response body. ", err)
    }
    // get 3rd div
    komentarz := document.Find("div").Eq(3).Text()
    //remove empty paragraphs
    komentarz = strings.Replace(komentarz, "\n\n", "\n", -1)
    // TODO - make SSML
    log.Println(komentarz)
    // compute signature
    h := sha1.New()
    h.Write([]byte(komentarz))
    bs := h.Sum(nil)
    log.Printf("%x\n", bs)
    // extract urls
    log.Println(xurls.Relaxed().FindAllString(komentarz, -1))
    // Initialize a session that the SDK uses to load
    // credentials from the shared credentials file. (~/.aws/credentials).
    sess := session.Must(session.NewSessionWithOptions(session.Options{
        SharedConfigState: session.SharedConfigEnable,
    }))
    // Create Polly client
    svc := polly.New(sess)
    // Split into paragraphs
    paragraphs := strings.Split(komentarz, "\n")
    // create filename (prefix + hash
    fn := fmt.Sprintf("icm_%x", bs)
    // Upload komentarz
    err = addTextToS3(sess, komentarz, fn + ".txt")
    if err != nil {
        log.Print(err.Error())
    }
    var link string
    link, err = getFileLink(sess, fn + ".txt")
    if err != nil {
        log.Print(err.Error())
    }
    fmt.Println(link)
    // Convert each paragraph into speach with Polly and upload to S3
    for i, paragraph := range paragraphs {
        if len(paragraph) < 5 {
            continue
        }
        log.Println(paragraph)

        // Output to MP3 using voice Maja (PL)
        input := &polly.SynthesizeSpeechInput{OutputFormat: aws.String("mp3"), Text: aws.String(paragraph), VoiceId: aws.String("Maja")}

        output, err := svc.SynthesizeSpeech(input)
        if err != nil {
            log.Println("Got error when calling SynthesizeSpeech:")
            log.Print(err.Error())
            continue
        }
        // create filename (prefix, hash, part number + extension)
        fna := fn + "_" + strconv.Itoa(i) + ".mp3"
        // Upload audio file
        err = addAudiostreamToS3(sess, output, fna)
        if err != nil {
            log.Print(err.Error())
            continue
        }
        link, err = getFileLink(sess, fna)
        if err != nil {
            log.Print(err.Error())
            continue
        }
        fmt.Println(link)
    }

}

// Save Audiostream generated by Polly to S3
func addAudiostreamToS3(s *session.Session, speachParagraph *polly.SynthesizeSpeechOutput, fileName string) error {

    buffer := streamToByte(speachParagraph.AudioStream)
    size := int64(len(buffer))

    // Config settings: this is where you choose the bucket, filename, content-type etc.
    // of the file you're uploading.
    _, err := s3.New(s).PutObject(&s3.PutObjectInput{
        Bucket:               aws.String(S3Bucket),
        Key:                  aws.String(fileName),
        ACL:                  aws.String("private"),
        Body:                 bytes.NewReader(buffer),
        ContentLength:        aws.Int64(size),
        ContentType:          aws.String(http.DetectContentType(buffer)),
        ContentDisposition:   aws.String("attachment"),
        ServerSideEncryption: aws.String("AES256"),
    })
    return err
}

// Save text (string) to S3
func addTextToS3(s *session.Session, comm string, fileName string) error {

    buffer := []byte(comm)
    size := int64(len(buffer))

    // Config settings: this is where you choose the bucket, filename, content-type etc.
    // of the file you're uploading.
    _, err := s3.New(s).PutObject(&s3.PutObjectInput{
        Bucket:               aws.String(S3Bucket),
        Key:                  aws.String(fileName),
        ACL:                  aws.String("private"),
        Body:                 bytes.NewReader(buffer),
        ContentLength:        aws.Int64(size),
        ContentType:          aws.String(http.DetectContentType(buffer)),
        ContentDisposition:   aws.String("attachment"),
        ServerSideEncryption: aws.String("AES256"),
    })
    return err
}

// Get public time-limited link to private object in S3 bucket
// f what you want is just the URL of a public access object you can build the URL yourself:
// https://<region>.amazonaws.com/<bucket-name>/<key>
func getFileLink(s *session.Session, fileName string) (string, error) {

    req, _ := s3.New(s).GetObjectRequest(&s3.GetObjectInput{
        Bucket:             aws.String(S3Bucket),
        Key:                aws.String(fileName),
    })
    url, err := req.Presign(LinkExpiration * time.Minute) // Set link expiration time

    return url, err
}

// ICM is using ISO-8859-2 which must be converted to UTF
func fetchUtf8Bytes(url string) ([]byte, error) {
    res, err := http.Get(url)
    if err != nil {
        return nil, err
    }

    contentType := res.Header.Get("Content-Type") // Optional, better guessing
    utf8reader, err := charset.NewReader(res.Body, contentType)
    if err != nil {
        return nil, err
    }

    return ioutil.ReadAll(utf8reader)
}

// convert AudioStreams to []byte 
func streamToByte(stream io.Reader) []byte {
    buf := new(bytes.Buffer)
    buf.ReadFrom(stream)
    return buf.Bytes()
}
